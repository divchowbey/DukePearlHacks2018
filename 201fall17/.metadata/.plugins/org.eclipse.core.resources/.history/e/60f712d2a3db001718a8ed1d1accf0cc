
/**
 *	Interface that all compression suites must implement. That is they must be
 *	able to compress a file and also reverse/decompress that process.
 * 
 *	@author Brian Lavallee
 *	@since 5 November 2015
 *  @author Owen Atrachan
 *  @since December 1, 2016
 */
public class HuffProcessor {

	public static final int BITS_PER_WORD = 8;
	public static final int BITS_PER_INT = 32;
	public static final int ALPH_SIZE = (1 << BITS_PER_WORD); // or 256
	public static final int PSEUDO_EOF = ALPH_SIZE;
	public static final int HUFF_NUMBER = 0xface8200;
	public static final int HUFF_TREE  = HUFF_NUMBER | 1;
	public static final int HUFF_COUNTS = HUFF_NUMBER | 2;

	public enum Header{TREE_HEADER, COUNT_HEADER};
	public Header myHeader = Header.TREE_HEADER;
	
	/**
	 * Compresses a file. Process must be reversible and loss-less.
	 *
	 * @param in
	 *            Buffered bit stream of the file to be compressed.
	 * @param out
	 *            Buffered bit stream writing to the output file.
	 */
	public void compress(BitInputStream in, BitOutputStream out){
	    while (true){
	        int val = in.readBits(BITS_PER_WORD);
	        if (val == -1) break;
	        
	        out.writeBits(BITS_PER_WORD, val);
	    }
	}

	/**
	 * Decompresses a file. Output file must be identical bit-by-bit to the
	 * original.
	 *
	 * @param in
	 *            Buffered bit stream of the file to be decompressed.
	 * @param out
	 *            Buffered bit stream writing to the output file.
	 */
	public void decompress(BitInputStream in, BitOutputStream out){
	    while (true){
            int val = in.readBits(BITS_PER_WORD);
            if (val == -1) break;
            
            out.writeBits(BITS_PER_WORD, val);
        }
	}
	
	public HuffNode readTreeHeader(BitInputStream reader) {
		int currentVal = reader.readBits(1); // store the first bit in a temp var
		
		if (currentVal == 0){
		    HuffNode left = readTreeHeader(reader);
		    HuffNode right = readTreeHeader(reader);
		    return new HuffNode(0,0,left,right); // recursively builds a tree based on the input stream
		}
		else{
			return new HuffNode(reader.readBits(BITS_PER_WORD + 1),0); // return a leaf with null children 
		}

	}

			
	}
	
	
	
	
	
	
	public void setHeader(Header header) {
        myHeader = header;
        System.out.println("header set to "+myHeader);
    }
}